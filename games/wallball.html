<!DOCTYPE html>

<head></head>
    <title>Wall Ball</title>
  <style>
    #canvas {
      border-width: 1px;
    }
  </style>
</head>


<body style="overflow: hidden;width:100%;height:100%;padding:0%;
      margin:0%;border:0px;">
    <canvas id="canvas" tabindex="1">Your browser does not support the HTML5 canvas tag.</canvas>
    </body>
    <script>
var canvas = document.querySelector("#canvas");
canvas.width = document.documentElement.clientWidth;
canvas.height = document.documentElement.clientHeight;

var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');

// Key Codes
var A = 65;
var D = 68;
var LEFT = 37;
var RIGHT = 39;

// Keep track of gameOver for restart
var gameOver = false;

// Keep track of pressed keys
var keys = {
  A: false,
  D: false,
  LEFT: false,
  RIGHT: false,
};

// Create a rectangle object - for paddles, ball, etc
function makeRect(x, y, width, height, speed, color) {
  if (!color) color = '#000000';
  return {
    x: x,
    y: y,
    w: width,
    h: height,
    s: speed,
    c: color,
    draw: function() {
      context.fillStyle = this.c;
      context.fillRect(this.x, this.y, this.w, this.h);
    }
  };
}
function makeEllipse(x, y, width, height, speed, color) {
  if (!color) color = '#000000';
  return {
    x: x,
    y: y,
    w: width,
    h: height,
    s: speed,
    c: color,
    draw: function() {
      context.fillStyle = this.c;
      context.beginPath();
      context.ellipse(this.x,this.y,this.w/2,this.h/2,0,0,2*Math.PI);
      context.strokeStyle = this.c;
      context.stroke();
      context.fill();
    }
  };
}

function makeCircle(x, y, radius, speed, color) {
  if (!color) color = '#000000';
  return {
    x: x,
    y: y,
    r: radius,
    s: speed,
    c: color,
    draw: function() {
      context.fillStyle = this.c;
      context.beginPath();
      context.arc(this.x,this.y,this.r,0,2*Math.PI);
      context.strokeStyle = this.c;
      context.stroke();
      context.fill();
    }
  };
}	   
// Create the wall
var wallThickness = canvas.height*0.2;
var floor = makeRect(wallThickness,wallThickness,canvas.width-(2*wallThickness),canvas.height-wallThickness,0, '#F0F8FF');
// invisible spot where the ball hits the wall
var midWall = canvas.height*0.1;
//var leftCorner =
//var rightCorner =


// Create the paddles
var paddleWidth = 0.1*canvas.width;
var paddleHeight = 0.020*canvas.width;
var leftPaddle = makeRect(25, canvas.height-paddleHeight-25, paddleWidth, paddleHeight, 5, '#eebb99');
var rightPaddle = makeRect(canvas.width - paddleWidth - 25, canvas.height-paddleHeight-25, paddleWidth, paddleHeight, 5, '#eebb99');
// how far between two hands
var armLength = canvas.width*0.2;

// Keep track of the score
var lives = 1;
var score = 0;

// Create the ball
var ballLength = 0.008*canvas.width;
var ballSpeed = 2;
var ball = makeCircle(0, 0, ballLength, ballSpeed, '#FFA62F');



// Modify the ball object to have two speed properties, one for X and one for Y
ball.sX = ballSpeed;
ball.sY = ballSpeed / 2;

// Randomize initial direction
if (Math.random() > 0.5) {
  ball.sX *= -1;
}
// Randomize initial direction
if (Math.random() > 0.5) {
  ball.sY *= -1;
}



// Reset the ball's position and speed after scoring
function resetBall() {
  ball.x = canvas.width / 2 - ball.r / 2;
  ball.y = canvas.height / 2 - ball.r / 2;
  ball.sX = ballSpeed;
  ball.sY = ballSpeed / 2;
}

// Bounce the ball off of a paddle
function bounceBall() {
	// Increase and reverse the Y speed
	if (ball.sY > 0) {
  	ball.sY += 1;
    // Add some "spin"
    if (keys.LEFT) {
      ball.sX -= 1;
    } else if (keys.RIGHT) {
      ball.sX += 1;
    }
  } else {
  	ball.sY -= 1;
    // Add some "spin"
    if (keys.A) {
      ball.sX -= 1;
    } else if (keys.D) {
      ball.sX += 1
    }
  }
  ball.sY *= -1;
  score +=1;
}

// Listen for keydown events
canvas.addEventListener('keydown', function(e) {
  if (e.keyCode === A) {
    keys.A = true;
  }
  if (e.keyCode === D) {
    keys.D = true;
  }
  if (e.keyCode === LEFT) {
    keys.LEFT = true;
  }
  if (e.keyCode === RIGHT) {
    keys.RIGHT = true;
  }
});

// Listen for keyup events
canvas.addEventListener('keyup', function(e) {
  if (e.keyCode === A) {
    keys.A = false;
  }
  if (e.keyCode === D) {
    keys.D = false;
  }
  if (e.keyCode === LEFT) {
    keys.LEFT = false;
  }
  if (e.keyCode === RIGHT) {
    keys.RIGHT = false;
  }
});
	    
//Listen for mouse move
var mouseX = 0;
var mouseY = 0;
function mouse(e) {
    var pos = getMousePos(canvas, e);
    mouseX = pos.x;
    mouseY = pos.y;
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
        y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
    };
}
	    
// Show the menu
function menu() {
  erase();
  // Show the menu
  context.fillStyle = '#000000';
  context.font = '40px Arial';
  context.textAlign = 'center';
  context.fillText('Wall Ball', canvas.width / 2, canvas.height / 4);
  context.font = '18px Arial';
  context.fillText('How many times can you hit the ball?',canvas.width / 2, canvas.height / 3)
  context.fillText('Click to Start', canvas.width / 2, canvas.height / 2);
  context.font = '14px Arial';
  context.textAlign = 'center';
  context.fillText('Left Hand: A and D keys. Right Hand: LEFT and RIGHT keys', canvas.width/2, (canvas.height / 3) * 2);
  // Start the game on a click
  canvas.addEventListener('click', startGame);
}

// Start the game
function startGame() {
// Don't accept any more clicks
  canvas.removeEventListener('click', startGame);
    //Add mouse listener
  window.addEventListener('mousemove', mouse, false);
  // Put the ball in place
  resetBall();
  // Kick off the game loop
  draw();
}

// Show the end game screen
function endGame() {
  erase();
  context.fillStyle = '#000000';
  context.font = '24px Arial';
  context.textAlign = 'center';
  context.fillText('Not bad, '+score+' times!', canvas.width/2, canvas.height/2);
  context.fillText('Can you do better? CLICK TO PLAY AGAIN!',canvas.width/2, canvas.height/2+50);
  lives = 1;
  score = 0;
  canvas.addEventListener('click', startGame);
}

// Clear the canvas
function erase() {
  context.fillStyle = '#FFFFFF';
  context.fillRect(0, 0, canvas.width, canvas.height);
}

// Main draw loop
function draw() {
  resize();
  erase();
  // Move the paddles
  if (keys.A) {
    leftPaddle.x -= leftPaddle.s;
  }
  if (keys.D) {
    leftPaddle.x += leftPaddle.s;
  }
  if (keys.LEFT) {
    rightPaddle.x -= rightPaddle.s;
  }
  if (keys.RIGHT) {
    rightPaddle.x += rightPaddle.s;
  }
  // move the paddles with mouse simplified controls
  if (mouseY>rightPaddle.y){
      if (mouseX>rightPaddle.x){
          rightPaddle.x += rightPaddle.s;
      }
      if (mouseX<leftPaddle.x){
          leftPaddle.x -= leftPaddle.s;
      }
  }
  // Move the ball
  ball.x += ball.sX;
  ball.y += ball.sY;
  // calculate where invisible middle of wall is called midWall
  // Bounce the ball off the top/left/right
  if (ball.y < midWall) {
    ball.sY *= -1;
  }else if(ball.x<midWall || ball.x + ball.r > canvas.width-midWall){
      ball.sX *= -1;
  }

  // Dont let the paddles overlap

  if (Math.abs(leftPaddle.x-rightPaddle.x)<leftPaddle.w){
      if(keys.D||rightPaddle.x===midWall||mouseX>rightPaddle.x){
          rightPaddle.x = leftPaddle.x+leftPaddle.w;
      }else{
          leftPaddle.x = rightPaddle.x-leftPaddle.w;
          }
  }
  if (Math.abs(leftPaddle.x-rightPaddle.x)>armLength){
      if(keys.A||mouseX<leftPaddle.x){
          rightPaddle.x = leftPaddle.x+armLength;
      }else{
          leftPaddle.x = rightPaddle.x-armLength;
      }
  }
  // Don't let the paddles go off screen
  [leftPaddle, rightPaddle].forEach(function(paddle) {
    if (paddle.x < midWall) {
      paddle.x = midWall;
    }
    if (paddle.x + paddle.w > canvas.width-midWall) {
      paddle.x = canvas.width - paddle.w-midWall;
    }
  });

  // Bounce the ball off the paddles
  if (ball.x + ball.r/2 >= leftPaddle.x && ball.x + ball.r/2 <= leftPaddle.x + leftPaddle.w) {
    if (ball.y + ball.r >= leftPaddle.y) {
      bounceBall();
    }
  }
  if (ball.x + ball.r/2 >= rightPaddle.x && ball.x + ball.r/2 <= rightPaddle.x + rightPaddle.w) {
    if (ball.y + ball.r >= rightPaddle.y) {
      bounceBall();
    }
  }
  // Lose life if the ball goes past a paddle
  if (ball.y + ball.r > rightPaddle.y + rightPaddle.h) {
    lives--;
    resetBall();
    ball.sY *= -1;
  }
  // Draw the paddles and ball
  floor.draw();
  coin.update();
  coin.render();
  leftPaddle.draw();
  rightPaddle.draw();
  ball.draw();
  // Draw the scores
  context.fillStyle = '#000000';
  context.font = '24px Arial';
  context.textAlign = 'right';
  context.fillText('Score: ' + score, canvas.width - 20, 24);
  // End the game or keep going
  if (lives <= 0) {
  	endGame();
  } else {
  	window.requestAnimationFrame(draw);
  }
}

function resize() {
  var width = document.documentElement.clientWidth;
  var height = document.documentElement.clientHeight;
  if (canvas.width != width ||
      canvas.height != height) {
     canvas.width = width;
     canvas.height = height;
     // Re-create the ball and paddles
    ballLength = 0.008*canvas.width;
    ball = makeCircle(0, 0, ballLength, ballSpeed, '#FFA62F');
    paddleWidth = 0.1*canvas.width;
    paddleHeight = 0.020*canvas.width;
    leftPaddle = makeRect(25, canvas.height-paddleHeight-25, paddleWidth, paddleHeight, 5, '#eebb99');
    rightPaddle = makeRect(canvas.width - paddleWidth - 25, canvas.height-paddleHeight-25, paddleWidth, paddleHeight, 5, '#eebb99');
    armLength = canvas.width*0.2;
    wallThickness = canvas.height*0.2;
    floor = makeRect(wallThickness,wallThickness,canvas.width-(2*wallThickness),canvas.height-wallThickness,0, '#F0F8FF');
    midWall = canvas.height*0.1;
    resetBall();
  }
}
function sprite (options) {
	
		var that = {},
			frameIndex = 0,
			tickCount = 0,
			ticksPerFrame = options.ticksPerFrame || 0,
			numberOfFrames = options.numberOfFrames || 1;
		
		that.context = options.context;
		that.width = options.width;
		that.height = options.height;
		that.image = options.image;
		
		that.update = function () {
            tickCount += 1;
            if (tickCount > ticksPerFrame) {
				tickCount = 0;
				
                // If the current frame index is in range
                if (frameIndex < numberOfFrames - 1) {	
                    // Go to the next frame
                    frameIndex += 1;
                } else {
                    frameIndex = 0;
                }
            }
        };
		
		that.render = function () {
		
		  // Clear the canvas
		  that.context.clearRect(0, 0, that.width, that.height);
		  
		  // Draw the animation
		  that.context.drawImage(
		    that.image,
		    frameIndex * that.width / numberOfFrames,
		    0,
		    that.width / numberOfFrames,
		    that.height,
		    0,
		    0,
		    that.width / numberOfFrames,
		    that.height);
		};
		
		return that;
	}	    
	    
// Create sprite sheet
coinImage = new Image();	
	
// Create sprite
coin = sprite({
	context: canvas.getContext("2d"),
	width: 1000,
	height: 100,
	image: coinImage,
	numberOfFrames: 10,
	ticksPerFrame: 4
});	    
// Start game	    
coinImage.addEventListener("load", menu());
coinImage.src = "images/coin-sprite-animation.png";

canvas.focus();
    </script>
</html>
